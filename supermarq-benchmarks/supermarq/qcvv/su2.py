# Copyright 2021 The Cirq Developers
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Tooling for interleaved randomised benchmarking
"""

from __future__ import annotations

import random
from collections.abc import Iterable, Sequence
from dataclasses import dataclass
import math

import cirq
import numpy as np
import pandas as pd
import seaborn as sns
from scipy.stats import linregress
from tqdm.contrib.itertools import product

from supermarq.qcvv.base_experiment import (
    BenchmarkingExperiment,
    BenchmarkingResults,
    Sample,
    ResultsT,
)


@dataclass(frozen=True)
class SU2Results(BenchmarkingResults):
    """Data structure for the SU2 experiment results."""

    experiment_name = "IRB"


class SU2(BenchmarkingExperiment[SU2Results]):
    r"""SU2 benchmarking experiment.
    TODO - Full description
    """

    def __init__(
        self,
        two_qubit_gate: cirq.Gate = cirq.CZ,
    ) -> None:
        """Args:
        two_qubit_gate: The Clifford gate to measure the gate error of.
        num_qubits: The number of qubits to experiment on. Must equal 2.
        """
        super().__init__(num_qubits=2)

        self.two_qubit_gate = two_qubit_gate
        """The two qubit gate to be benchmarked"""

    def _build_circuits(
        self,
        num_circuits: int,
        cycle_depths: Iterable[int],
    ) -> Sequence[Sample]:
        """Build a list of circuits required for the experiment. These circuits are stored in
        :class:`Sample` objects along with any additional data that is needed during the analysis.

        Args:
            num_circuits: Number of circuits to generate.
            cycle_depths: An iterable of the different cycle depths to use during the experiment.

        Returns:
           The list of experiment samples.
        """
        samples = []
        max_depth = max(cycle_depths)
        for depth, _ in product(cycle_depths, range(num_circuits), desc="Building circuits"):
            circuit = cirq.Circuit(
                *[self._component(two_qubit_gate=True) for _ in range(depth)],
                *[self._component(two_qubit_gate=False) for _ in range(2 * max_depth - depth)],
            )
            circuit_inv = cirq.inverse(circuit)
            # Decompose circuit inverse into a pair of single qubit rotation gates
            _, rot_1, rot_2 = cirq.kron_factor_4x4_to_2x2s(cirq.unitary(circuit_inv))

            if (op_1 := cirq.single_qubit_matrix_to_phxz(rot_1)) is not None:
                circuit += op_1(self.qubits[0])

            if (op_2 := cirq.single_qubit_matrix_to_phxz(rot_2)) is not None:
                circuit += op_2(self.qubits[1])

            circuit += cirq.measure(sorted(circuit.all_qubits()))

            samples.append(Sample(circuit=circuit, data={"num_cycles": depth}))
        return samples

    def _plot_results(self) -> None:
        """Plot the results of the experiment"""

    def _process_probabilities(self, samples: Sequence[Sample]) -> pd.DataFrame:
        """Processes the probabilities generated by sampling the circuits into a data frame
        needed for analyzing the results.

        Args:
            samples: The list of samples to process the results from.

        Returns:
            A data frame of the full results needed to analyse the experiment.
        """
        records = []
        for sample in samples:
            records.append(
                {
                    "num_cycles": sample.data["num_cycles"],
                    **sample.probabilities,
                }
            )

        return pd.DataFrame(records)

    def analyse_results(self, plot_results: bool = True) -> ResultsT:
        """Perform the experiment analysis and store the results in the `results` attribute.

        Args:
            plot_results: Whether to generate plots of the results. Defaults to False.

        Returns:
            A named tuple of the final results from the experiment.
        """

        fit = linregress(x=self.raw_data["num_cycles"], y=np.log(self.raw_data["00"] - 1/4))
        # Scale the y coordinate to account for limit of the decay being 1/4
        gate_fid = np.exp(fit.slope)
        gate_fid_std = fit.stderr * gate_fid
        return gate_fid, gate_fid_std

    @staticmethod
    def _reduce_clifford_seq(
        gate_seq: list[cirq.ops.SingleQubitCliffordGate],
    ) -> cirq.ops.SingleQubitCliffordGate:
        """Reduces a list of single qubit clifford gates to a single gate.
        Args:
            gate_seq: The list of gates.
        Returns:
            The single reduced gate
        """
        cur = gate_seq[0]
        for gate in gate_seq[1:]:
            cur = cur.merged_with(gate)
        return cur

    @classmethod
    def _random_single_qubit_clifford(cls) -> cirq.ops.SingleQubitCliffordGate:
        """Choose a random singe qubit clifford gate.
        Returns:
            The random clifford gate.
        """
        Id = cirq.ops.SingleQubitCliffordGate.I
        H = cirq.ops.SingleQubitCliffordGate.H
        S = cirq.ops.SingleQubitCliffordGate.Z_sqrt
        X = cirq.ops.SingleQubitCliffordGate.X
        Y = cirq.ops.SingleQubitCliffordGate.Y
        Z = cirq.ops.SingleQubitCliffordGate.Z

        set_A = [
            Id,
            S,
            H,
            cls._reduce_clifford_seq([H, S]),
            cls._reduce_clifford_seq([S, H]),
            cls._reduce_clifford_seq([H, S, H]),
        ]

        set_B = [Id, X, Y, Z]

        return cls._reduce_clifford_seq([random.choice(set_A), random.choice(set_B)])

    def _component(self, two_qubit_gate: bool):
        return cirq.Circuit(
            self._random_single_qubit_clifford().on(self.qubits[0]),
            self._random_single_qubit_clifford().on(self.qubits[1]),
            (self.two_qubit_gate(*self.qubits) if two_qubit_gate else []),
            cirq.X.on_each(*self.qubits),
            (self.two_qubit_gate(*self.qubits) if two_qubit_gate else []),
        )
